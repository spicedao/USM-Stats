{
    "abi": [
      {
        "inputs": [
          {
            "internalType": "contract IUSM",
            "name": "usm_",
            "type": "address"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
      },
      {
        "inputs": [],
        "name": "debtRatio",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "ratio",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "enum WadMath.Round",
            "name": "upOrDown",
            "type": "uint8"
          }
        ],
        "name": "ethBuffer",
        "outputs": [
          {
            "internalType": "int256",
            "name": "buffer",
            "type": "int256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "ethAmount",
            "type": "uint256"
          },
          {
            "internalType": "enum WadMath.Round",
            "name": "upOrDown",
            "type": "uint8"
          }
        ],
        "name": "ethToUsm",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "usmOut",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "enum IUSM.Side",
            "name": "side",
            "type": "uint8"
          }
        ],
        "name": "fumPrice",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "price",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "usm",
        "outputs": [
          {
            "internalType": "contract IUSM",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "enum IUSM.Side",
            "name": "side",
            "type": "uint8"
          }
        ],
        "name": "usmPrice",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "price",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "usmAmount",
            "type": "uint256"
          },
          {
            "internalType": "enum WadMath.Round",
            "name": "upOrDown",
            "type": "uint8"
          }
        ],
        "name": "usmToEth",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "ethOut",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      }
    ],
    "transactionHash": "0xe3ca1e02933d84ba09d26d7a4e4551234e1880644eb5f4eac328aad2890485ec",
    "receipt": {
      "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
      "from": "0x6b6d51559192B458420E678A543B3383668a360a",
      "contractAddress": null,
      "transactionIndex": 0,
      "gasUsed": "1052010",
      "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "blockHash": "0x2944a3d57a0a466178ce33b4e541e89ebd94bf3f10e461a1ba6b275ecbcac3e5",
      "transactionHash": "0xe3ca1e02933d84ba09d26d7a4e4551234e1880644eb5f4eac328aad2890485ec",
      "logs": [],
      "blockNumber": 25501679,
      "cumulativeGasUsed": "1052010",
      "status": 1,
      "byzantium": true
    },
    "args": [
      "0x6A518F9d1D55bFBC6f04EF071e18a5b01EEE434B"
    ],
    "solcInputHash": "abb1f64be19454ed92e8aad1010010f4",
    "metadata": "{\"compiler\":{\"version\":\"0.8.0+commit.c7dfd78e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IUSM\",\"name\":\"usm_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"debtRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum WadMath.Round\",\"name\":\"upOrDown\",\"type\":\"uint8\"}],\"name\":\"ethBuffer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"buffer\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum WadMath.Round\",\"name\":\"upOrDown\",\"type\":\"uint8\"}],\"name\":\"ethToUsm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usmOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IUSM.Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"fumPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usm\",\"outputs\":[{\"internalType\":\"contract IUSM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IUSM.Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"usmPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usmAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum WadMath.Round\",\"name\":\"upOrDown\",\"type\":\"uint8\"}],\"name\":\"usmToEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Alberto Cuesta Ca\\u00f1ada, Jacob Eliosoff, Alex Roan\",\"kind\":\"dev\",\"methods\":{\"debtRatio()\":{\"returns\":{\"ratio\":\"Debt ratio\"}},\"ethBuffer(uint8)\":{\"returns\":{\"buffer\":\"ETH buffer\"}},\"ethToUsm(uint256,uint8)\":{\"params\":{\"ethAmount\":\"The amount of ETH to convert\"},\"returns\":{\"usmOut\":\"The amount of USM\"}},\"fumPrice(uint8)\":{\"returns\":{\"price\":\"FUM price in ETH terms\"}},\"usmPrice(uint8)\":{\"returns\":{\"price\":\"USM price in ETH terms\"}},\"usmToEth(uint256,uint8)\":{\"params\":{\"usmAmount\":\"The amount of USM to convert\"},\"returns\":{\"ethOut\":\"The amount of ETH\"}}},\"title\":\"USM view-only proxy\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"debtRatio()\":{\"notice\":\"Calculate debt ratio.\"},\"ethBuffer(uint8)\":{\"notice\":\"Calculate the amount of ETH in the buffer.\"},\"ethToUsm(uint256,uint8)\":{\"notice\":\"Convert ETH amount to USM using the latest oracle ETH/USD price.\"},\"fumPrice(uint8)\":{\"notice\":\"Calculate the *marginal* price of FUM (in ETH terms) - that is, of the next unit, before price start sliding.\"},\"usmPrice(uint8)\":{\"notice\":\"Calculate the *marginal* price of USM (in ETH terms) - that is, of the next unit, before price start sliding.\"},\"usmToEth(uint256,uint8)\":{\"notice\":\"Convert USM amount to ETH using the latest oracle ETH/USD price.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/USMView.sol\":\"USMView\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":20000},\"remappings\":[]},\"sources\":{\"acc-erc20/contracts/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\",\"keccak256\":\"0xa38ec4e151e4d397d05bdfb94e6e4eb91e57a9fca3bc1c655289a4adf31a58fa\",\"license\":\"MIT\"},\"contracts/IUSM.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"acc-erc20/contracts/IERC20.sol\\\";\\nimport \\\"./WadMath.sol\\\";\\n\\nabstract contract IUSM is IERC20 {\\n    enum Side {Buy, Sell}\\n\\n    function mint(address to, uint minUsmOut) external virtual payable returns (uint);\\n    function burn(address from, address payable to, uint usmToBurn, uint minEthOut) external virtual returns (uint);\\n    function fund(address to, uint minFumOut) external virtual payable returns (uint);\\n    function defund(address from, address payable to, uint fumToBurn, uint minEthOut) external virtual returns (uint);\\n\\n    function refreshPrice() public virtual returns (uint price, uint updateTime);\\n\\n    function latestPrice() public virtual view returns (uint price, uint updateTime);\\n    function latestOraclePrice() public virtual view returns (uint price, uint updateTime);\\n    function ethPool() public virtual view returns (uint pool);\\n    function fumTotalSupply() public virtual view returns (uint supply);\\n    function bidAskAdjustment() public virtual view returns (uint adjustment);\\n    function timeSystemWentUnderwater() public virtual view returns (uint timestamp);\\n\\n    function ethBuffer(uint ethUsdPrice, uint ethInPool, uint usmSupply, WadMath.Round upOrDown) public virtual pure returns (int buffer);\\n    function debtRatio(uint ethUsdPrice, uint ethInPool, uint usmSupply) public virtual pure returns (uint ratio);\\n    function ethToUsm(uint ethUsdPrice, uint ethAmount, WadMath.Round upOrDown) public virtual pure returns (uint usmOut);\\n    function usmToEth(uint ethUsdPrice, uint usmAmount, WadMath.Round upOrDown) public virtual pure returns (uint ethOut);\\n    function usmPrice(Side side, uint ethUsdPrice, uint debtRatio_) public virtual pure returns (uint price);\\n    function fumPrice(Side side, uint ethUsdPrice, uint ethInPool, uint usmEffectiveSupply, uint fumSupply, uint adjustment) public virtual pure returns (uint price);\\n    function checkIfUnderwater(uint usmActualSupply, uint ethPool_, uint ethUsdPrice, uint oldTimeUnderwater, uint currentTime) public virtual pure returns (uint timeSystemWentUnderwater_, uint usmSupplyForFumBuys);\\n}\\n\",\"keccak256\":\"0xdb25a761debb1d2d232a9dafa5bcc9ac789bb80da06ad5dd36d4513e6aa5956e\",\"license\":\"GPL-3.0-or-later\"},\"contracts/USMView.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IUSM.sol\\\";\\n\\n/**\\n * @title USM view-only proxy\\n * @author Alberto Cuesta Ca\\u00f1ada, Jacob Eliosoff, Alex Roan\\n */\\ncontract USMView {\\n    IUSM public immutable usm;\\n\\n    constructor(IUSM usm_)\\n    {\\n        usm = usm_;\\n    }\\n\\n    // ____________________ External informational view functions ____________________\\n\\n    /**\\n     * @notice Calculate the amount of ETH in the buffer.\\n     * @return buffer ETH buffer\\n     */\\n    function ethBuffer(WadMath.Round upOrDown) external view returns (int buffer) {\\n        (uint price, ) = usm.latestPrice();\\n        buffer = usm.ethBuffer(price, usm.ethPool(), usm.totalSupply(), upOrDown);\\n    }\\n\\n    /**\\n     * @notice Convert ETH amount to USM using the latest oracle ETH/USD price.\\n     * @param ethAmount The amount of ETH to convert\\n     * @return usmOut The amount of USM\\n     */\\n    function ethToUsm(uint ethAmount, WadMath.Round upOrDown) external view returns (uint usmOut) {\\n        (uint price, ) = usm.latestPrice();\\n        usmOut = usm.ethToUsm(price, ethAmount, upOrDown);\\n    }\\n\\n    /**\\n     * @notice Convert USM amount to ETH using the latest oracle ETH/USD price.\\n     * @param usmAmount The amount of USM to convert\\n     * @return ethOut The amount of ETH\\n     */\\n    function usmToEth(uint usmAmount, WadMath.Round upOrDown) external view returns (uint ethOut) {\\n        (uint price, ) = usm.latestPrice();\\n        ethOut = usm.usmToEth(price, usmAmount, upOrDown);\\n    }\\n\\n    /**\\n     * @notice Calculate debt ratio.\\n     * @return ratio Debt ratio\\n     */\\n    function debtRatio() external view returns (uint ratio) {\\n        (uint price, ) = usm.latestPrice();\\n        ratio = usm.debtRatio(price, usm.ethPool(), usm.totalSupply());\\n    }\\n\\n    /**\\n     * @notice Calculate the *marginal* price of USM (in ETH terms) - that is, of the next unit, before price start sliding.\\n     * @return price USM price in ETH terms\\n     */\\n    function usmPrice(IUSM.Side side) external view returns (uint price) {\\n        (uint ethUsdPrice, ) = usm.latestPrice();\\n        price = usm.usmPrice(side, ethUsdPrice, usm.bidAskAdjustment());\\n    }\\n\\n    /**\\n     * @notice Calculate the *marginal* price of FUM (in ETH terms) - that is, of the next unit, before price start sliding.\\n     * @return price FUM price in ETH terms\\n     */\\n    function fumPrice(IUSM.Side side) external view returns (uint price) {\\n        (uint ethUsdPrice, ) = usm.latestPrice();\\n        uint ethPool = usm.ethPool();\\n        uint usmSupply = usm.totalSupply();\\n        uint oldTimeUnderwater = usm.timeSystemWentUnderwater();\\n        if (side == IUSM.Side.Buy) {\\n            (, usmSupply) = usm.checkIfUnderwater(usmSupply, ethPool, ethUsdPrice, oldTimeUnderwater, block.timestamp);\\n        }\\n        price = usm.fumPrice(side, ethUsdPrice, ethPool, usmSupply, usm.fumTotalSupply(), usm.bidAskAdjustment());\\n    }\\n}\\n\",\"keccak256\":\"0xbe8b897245038a9c72df32f27d229456e35b3f30b0fbda144bbd08b903ac693c\",\"license\":\"GPL-3.0-or-later\"},\"contracts/WadMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n * @title Fixed point arithmetic library\\n * @author Alberto Cuesta Ca\\u00f1ada, Jacob Eliosoff, Alex Roan\\n */\\nlibrary WadMath {\\n    enum Round {Down, Up}\\n\\n    uint public constant WAD = 10 ** 18;\\n    uint public constant WAD_MINUS_1 = WAD - 1;\\n    uint public constant WAD_OVER_10 = WAD / 10;\\n    uint public constant WAD_OVER_20 = WAD / 20;\\n    uint public constant HALF_TO_THE_ONE_TENTH = 933032991536807416;\\n    uint public constant LOG_2_WAD_SCALED = 158961593653514369813532673448321674075;   // log_2(10**18) * 2**121\\n    uint public constant LOG_2_E_SCALED_OVER_WAD = 3835341275459348170;                // log_2(e) * 2**121 / 10**18\\n\\n    function wadMul(uint x, uint y, Round upOrDown) internal pure returns (uint z) {\\n        z = (upOrDown == Round.Down ? wadMulDown(x, y) : wadMulUp(x, y));\\n    }\\n\\n    function wadMulDown(uint x, uint y) internal pure returns (uint z) {\\n        z = x * y;                  // Rounds down, truncating the last 18 digits.  So (imagining 2 dec places rather than 18):\\n        unchecked { z /= WAD; }     // 369 (3.69) * 271 (2.71) -> 99999 (9.9999) -> 999 (9.99).\\n    }\\n\\n    function wadMulUp(uint x, uint y) internal pure returns (uint z) {\\n        z = x * y + WAD_MINUS_1;    // Rounds up.  So (again imagining 2 decimal places):\\n        unchecked { z /= WAD; }     // 383 (3.83) * 235 (2.35) -> 90005 (9.0005), + 99 (0.0099) -> 90104, / 100 -> 901 (9.01).\\n    }\\n\\n    function wadDiv(uint x, uint y, Round upOrDown) internal pure returns (uint z) {\\n        z = (upOrDown == Round.Down ? wadDivDown(x, y) : wadDivUp(x, y));\\n    }\\n\\n    function wadDivDown(uint x, uint y) internal pure returns (uint z) {\\n        z = (x * WAD) / y;          // Rounds down: 199 (1.99) / 1000 (10) -> (199 * 100) / 1000 -> 19 (0.19: 0.199 truncated).\\n    }\\n\\n    function wadDivUp(uint x, uint y) internal pure returns (uint z) {\\n        z = x * WAD + y;            // 101 (1.01) / 1000 (10) -> (101 * 100 + 1000 - 1) / 1000 -> 11 (0.11 = 0.101 rounded up).\\n        unchecked { z -= 1; }       // Can do unchecked subtraction since division in next line will catch y = 0 case anyway\\n        z /= y;\\n    }\\n\\n    function wadMax(uint x, uint y) internal pure returns (uint z) {\\n        z = (x > y ? x : y);\\n    }\\n\\n    function wadMin(uint x, uint y) internal pure returns (uint z) {\\n        z = (x < y ? x : y);\\n    }\\n\\n    /**\\n     * @return exp Just returns `wadHalfExp(power, MAX_VALUE)`, ie, an approximation of 0.5**`power`, with `power` uncapped.\\n     */\\n    function wadHalfExp(uint power) internal pure returns (uint exp) {\\n        exp = wadHalfExp(power, type(uint).max);\\n    }\\n\\n    /**\\n     * @return exp a loose but \\\"gas-efficient\\\" approximation of 0.5**power, where power is rounded to the nearest 0.1, and is\\n     * capped at maxPower.  Note power is WAD-scaled (eg, 2.7364 * WAD), but maxPower is just a plain unscaled uint (eg, 10).\\n     * Negative powers are not handled (as implied by power being a uint).\\n     */\\n    function wadHalfExp(uint power, uint maxPower) internal pure returns (uint exp) {\\n        uint powerInTenthsUnscaled = power + WAD_OVER_20;       // Rounds 2.7499 -> 2.7, 2.7500 -> 2.8\\n        unchecked { powerInTenthsUnscaled /= WAD_OVER_10; }\\n        uint powerUnscaled;\\n        unchecked { powerUnscaled = powerInTenthsUnscaled / 10; }\\n        if (powerUnscaled <= maxPower) {    // If not, then 0.5**power is (more or less) tiny, so we just return exp = 0\\n            exp = wadPow(HALF_TO_THE_ONE_TENTH, powerInTenthsUnscaled);\\n        }\\n    }\\n\\n    /**\\n     * @notice Adapted from rpow() in https://github.com/dapphub/ds-math/blob/master/src/math.sol - thank you!\\n     *\\n     * This famous algorithm is called \\\"exponentiation by squaring\\\" and calculates x^n with x as fixed-point and n as regular\\n     * unsigned.\\n     *\\n     * It's O(log n), instead of O(n) for naive repeated multiplication.\\n     *\\n     * These facts are why it works:\\n     *\\n     * - If n is even, then x^n = (x^2)^(n/2).\\n     * - If n is odd,  then x^n = x * x^(n-1),\\n     *   and applying the equation for even x gives\\n     *   x^n = x * (x^2)^((n-1) / 2).\\n     *\\n     * Also, EVM division is flooring and floor[(n-1) / 2] = floor[n / 2].\\n     */\\n    function wadPow(uint x, uint n) internal pure returns (uint z) {\\n        unchecked { z = n % 2 != 0 ? x : WAD; }\\n\\n        unchecked { n /= 2; }\\n        bool divide;\\n        while (n != 0) {\\n            x = wadMulDown(x, x);\\n\\n            unchecked { divide = n % 2 != 0; }\\n            if (divide) {\\n                z = wadMulDown(z, x);\\n            }\\n            unchecked { n /= 2; }\\n        }\\n    }\\n\\n    /**\\n     * @return z The (approximate!) natural logarithm of x, where both x and the return value are in WAD fixed-point form.\\n     * @dev We're given X = x * 10**18 (WAD-formatted); we want to return Z = z * 10**18, where z =~ ln(x); and we have\\n     * `log_2(x)` below, which returns Y = y * 2**121, where y =~ log2(x).  So the math we use is:\\n     *\\n     *     K1 = log2(10**18) * 2**121\\n     *     K2 = log2(e) * 2**121 / 10**18\\n     *     Z = (`log_2(X)` - K1) / K2\\n     *       = (`log_2(x * 10**18)` - log2(10**18) * 2**121) / (log2(e) * 2**121 / 10**18)\\n     *       = (log2(x * 10**18) * 2**121 - log2(10**18) * 2**121) / (log2(e) * 2**121 / 10**18)\\n     *       = (log2(x * 10**18) - log2(10**18)) / (log2(e) / 10**18)\\n     *       = (log2(x) / log2(e)) * 10**18\\n     *       = ln(x) * 10**18\\n     */\\n    function wadLog(uint x) internal pure returns (int z) {\\n        require(x <= type(uint128).max, \\\"x overflow\\\");\\n        z = int(log_2(uint128(x)));\\n        unchecked { z = (z - int(LOG_2_WAD_SCALED)) / int(LOG_2_E_SCALED_OVER_WAD); }\\n    }\\n\\n    /**\\n     * @return z e raised to the given power `y` (approximately!), specified in WAD 18-digit fixed-point form, and in, again,\\n     * WAD form.\\n     * @notice This library works only on positive uint inputs.  If you have a negative exponent (y < 0), you can calculate it\\n     * using this identity:\\n     *\\n     *     wadExp(y < 0) = 1 / wadExp(-y > 0) = WAD.div(wadExp(-y > 0))\\n     *\\n     * @dev We're given Y = y * 10**18 (WAD-formatted); we want to return Z = z * 10**18, where z =~ e**y; and we have\\n     * `pow_2(X = x * 2**121)` below, which returns y =~ 2**x = 2**(X / 2**121).  So the math we use is:\\n     *\\n     *     K1 = log2(10**18) * 2**121\\n     *     K2 = log2(e) * 2**121 / 10**18\\n     *     Z = `pow_2(K1 + K2 * Y)`\\n     *       = 2**((K1 + K2 * Y) / 2**121)\\n     *       = 2**((log2(10**18) * 2**121 + (log2(e) * 2**121 / 10**18) * (y * 10**18)) / 2**121)\\n     *       = 2**(log2(10**18) + log2(e) * y)\\n     *       = 2**(log2(10**18)) * 2**(log2(e) * y)\\n     *       = 10**18 * (2**log2(e))**y\\n     *       = e**y * 10**18\\n     */\\n    function wadExp(uint y) internal pure returns (uint z) {\\n        uint exponent = LOG_2_WAD_SCALED + LOG_2_E_SCALED_OVER_WAD * y;\\n        require(exponent <= type(uint128).max, \\\"exponent overflow\\\");\\n        z = pow_2(uint128(exponent));\\n    }\\n\\n    /**\\n     * @return z The given number `x` raised to power `y` (approximately!), with all of `x`, `y` and `z` in WAD 18-digit\\n     * fixed-point form.\\n     * @notice This library works only on positive uint inputs.  If you have a negative base (x < 0) or a negative exponent\\n     * (y < 0), you can calculate them using these identities:\\n     *\\n     *     wadExp(x < 0, y) = -wadExp(-x > 0, y)\\n     *     wadExp(x, y < 0) = 1 / wadExp(x, -y > 0) = WAD.div(wadExp(x, -y > 0))\\n     *\\n     * @dev We're given X = x * 10**18, and Y = y * 10**18 (both WAD-formatted); we want Z = z * 10**18, where z =~ x**y; and\\n     * we have `log_2(x)`, which returns log2(x) * 2**121, and `pow_2(X = x * 2**121)`, which returns 2**x = 2**(X / 2**121).\\n     * The math we use is (essentially):\\n     *\\n     *     K = log2(10**18) * 2**121\\n     *     Z = `pow_2(K + (log_2(X) - K) * Y / 10**18)`\\n     *       = 2**((K + (log2(X) * 2**121 - K) * Y / 10**18) / 2**121)\\n     *       = 2**((log2(10**18) * 2**121 + (log2(x * 10**18) * 2**121 - log2(10**18) * 2**121) * (y * 10**18) / 10**18) / 2**121)\\n     *       = 2**(log2(10**18) + (log2(x * 10**18) - log2(10**18)) * y)\\n     *       = 2**(log2(10**18) + log2(x) * y)\\n     *       = 2**(log2(10**18)) * 2**(log2(x) * y)\\n     *       = 10**18 * (2**log2(x))**y\\n     *       = x**y * 10**18\\n     *\\n     * Except, because we're working with unsigned numbers, we need to be careful to handle two cases separately:\\n     * log_2(X) >= K, and log_2(X) < K.\\n     */\\n    function wadExp(uint x, uint y) internal pure returns (uint z) {\\n        require(x <= type(uint128).max, \\\"x overflow\\\");\\n        uint logX = log_2(uint128(x));\\n        uint exponent;\\n        if (logX >= LOG_2_WAD_SCALED) {\\n            // Case 1: Z = pow_2(LOG_2_WAD_SCALED + (log_2(X) - LOG_2_WAD_SCALED) * Y / WAD):\\n            unchecked { exponent = logX - LOG_2_WAD_SCALED; }\\n            exponent = LOG_2_WAD_SCALED + wadMulDown(exponent, y);\\n            require(exponent <= type(uint128).max, \\\"exponent overflow\\\");\\n            z = pow_2(uint128(exponent));\\n        } else {\\n            // Case 2: Z = pow_2(LOG_2_WAD_SCALED - (LOG_2_WAD_SCALED - log_2(X)) * Y / WAD):\\n            uint exponentSubtrahend;\\n            unchecked { exponentSubtrahend = LOG_2_WAD_SCALED - logX; }\\n            exponentSubtrahend = wadMulDown(exponentSubtrahend, y);\\n            if (exponentSubtrahend <= LOG_2_WAD_SCALED) {\\n                unchecked { exponent = LOG_2_WAD_SCALED - exponentSubtrahend; }\\n                z = pow_2(uint128(exponent));   // Needn't check for overflow since exp <= LOG_2_WAD_SCALED < type(uint128).max\\n            } else {\\n                // z = 0: exponent would be < 0, so pow_2(exponent) is vanishingly small (as a WAD-formatted num) - call it 0\\n            }\\n        }\\n    }\\n\\n    /* ____________________ Exponential/logarithm fns borrowed from Yield Protocol ____________________\\n     *\\n     * See https://github.com/yieldprotocol/yieldspace-v1/blob/master/contracts/YieldMath.sol for Yield's code, originally\\n     * developed by the math gurus at https://www.abdk.consulting/.\\n     */\\n\\n    /**\\n     * Calculate base 2 logarithm of an unsigned 128-bit integer number.  Revert in case x is zero.\\n     *\\n     * @param x number to calculate base 2 logarithm of\\n     * @return z base 2 logarithm of x, multiplied by 2^121\\n     */\\n    function log_2(uint128 x)\\n        internal pure returns (uint128 z)\\n    {\\n        unchecked {\\n            require (x != 0, \\\"x = 0\\\");\\n\\n            uint b = x;\\n\\n            uint l = 0xFE000000000000000000000000000000;\\n\\n            if (b < 0x10000000000000000) {l -= 0x80000000000000000000000000000000; b <<= 64;}\\n            if (b < 0x1000000000000000000000000) {l -= 0x40000000000000000000000000000000; b <<= 32;}\\n            if (b < 0x10000000000000000000000000000) {l -= 0x20000000000000000000000000000000; b <<= 16;}\\n            if (b < 0x1000000000000000000000000000000) {l -= 0x10000000000000000000000000000000; b <<= 8;}\\n            if (b < 0x10000000000000000000000000000000) {l -= 0x8000000000000000000000000000000; b <<= 4;}\\n            if (b < 0x40000000000000000000000000000000) {l -= 0x4000000000000000000000000000000; b <<= 2;}\\n            if (b < 0x80000000000000000000000000000000) {l -= 0x2000000000000000000000000000000; b <<= 1;}\\n\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000;}\\n            /* Precision reduced to 64 bits\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2;}\\n            b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) l |= 0x1;\\n            */\\n\\n            z = uint128(l);\\n        }\\n    }\\n\\n    /**\\n     * Calculate 2 raised into given power.\\n     *\\n     * @param x power to raise 2 into, multiplied by 2^121\\n     * @return z 2 raised into given power\\n     */\\n    function pow_2(uint128 x)\\n        internal pure returns (uint128 z)\\n    {\\n        unchecked {\\n            uint r = 0x80000000000000000000000000000000;\\n            if (x & 0x1000000000000000000000000000000 > 0) r = r * 0xb504f333f9de6484597d89b3754abe9f >> 127;\\n            if (x & 0x800000000000000000000000000000 > 0) r = r * 0x9837f0518db8a96f46ad23182e42f6f6 >> 127;\\n            if (x & 0x400000000000000000000000000000 > 0) r = r * 0x8b95c1e3ea8bd6e6fbe4628758a53c90 >> 127;\\n            if (x & 0x200000000000000000000000000000 > 0) r = r * 0x85aac367cc487b14c5c95b8c2154c1b2 >> 127;\\n            if (x & 0x100000000000000000000000000000 > 0) r = r * 0x82cd8698ac2ba1d73e2a475b46520bff >> 127;\\n            if (x & 0x80000000000000000000000000000 > 0) r = r * 0x8164d1f3bc0307737be56527bd14def4 >> 127;\\n            if (x & 0x40000000000000000000000000000 > 0) r = r * 0x80b1ed4fd999ab6c25335719b6e6fd20 >> 127;\\n            if (x & 0x20000000000000000000000000000 > 0) r = r * 0x8058d7d2d5e5f6b094d589f608ee4aa2 >> 127;\\n            if (x & 0x10000000000000000000000000000 > 0) r = r * 0x802c6436d0e04f50ff8ce94a6797b3ce >> 127;\\n            if (x & 0x8000000000000000000000000000 > 0) r = r * 0x8016302f174676283690dfe44d11d008 >> 127;\\n            if (x & 0x4000000000000000000000000000 > 0) r = r * 0x800b179c82028fd0945e54e2ae18f2f0 >> 127;\\n            if (x & 0x2000000000000000000000000000 > 0) r = r * 0x80058baf7fee3b5d1c718b38e549cb93 >> 127;\\n            if (x & 0x1000000000000000000000000000 > 0) r = r * 0x8002c5d00fdcfcb6b6566a58c048be1f >> 127;\\n            if (x & 0x800000000000000000000000000 > 0) r = r * 0x800162e61bed4a48e84c2e1a463473d9 >> 127;\\n            if (x & 0x400000000000000000000000000 > 0) r = r * 0x8000b17292f702a3aa22beacca949013 >> 127;\\n            if (x & 0x200000000000000000000000000 > 0) r = r * 0x800058b92abbae02030c5fa5256f41fe >> 127;\\n            if (x & 0x100000000000000000000000000 > 0) r = r * 0x80002c5c8dade4d71776c0f4dbea67d6 >> 127;\\n            if (x & 0x80000000000000000000000000 > 0) r = r * 0x8000162e44eaf636526be456600bdbe4 >> 127;\\n            if (x & 0x40000000000000000000000000 > 0) r = r * 0x80000b1721fa7c188307016c1cd4e8b6 >> 127;\\n            if (x & 0x20000000000000000000000000 > 0) r = r * 0x8000058b90de7e4cecfc487503488bb1 >> 127;\\n            if (x & 0x10000000000000000000000000 > 0) r = r * 0x800002c5c8678f36cbfce50a6de60b14 >> 127;\\n            if (x & 0x8000000000000000000000000 > 0) r = r * 0x80000162e431db9f80b2347b5d62e516 >> 127;\\n            if (x & 0x4000000000000000000000000 > 0) r = r * 0x800000b1721872d0c7b08cf1e0114152 >> 127;\\n            if (x & 0x2000000000000000000000000 > 0) r = r * 0x80000058b90c1aa8a5c3736cb77e8dff >> 127;\\n            if (x & 0x1000000000000000000000000 > 0) r = r * 0x8000002c5c8605a4635f2efc2362d978 >> 127;\\n            if (x & 0x800000000000000000000000 > 0) r = r * 0x800000162e4300e635cf4a109e3939bd >> 127;\\n            if (x & 0x400000000000000000000000 > 0) r = r * 0x8000000b17217ff81bef9c551590cf83 >> 127;\\n            if (x & 0x200000000000000000000000 > 0) r = r * 0x800000058b90bfdd4e39cd52c0cfa27c >> 127;\\n            if (x & 0x100000000000000000000000 > 0) r = r * 0x80000002c5c85fe6f72d669e0e76e411 >> 127;\\n            if (x & 0x80000000000000000000000 > 0) r = r * 0x8000000162e42ff18f9ad35186d0df28 >> 127;\\n            if (x & 0x40000000000000000000000 > 0) r = r * 0x80000000b17217f84cce71aa0dcfffe7 >> 127;\\n            if (x & 0x20000000000000000000000 > 0) r = r * 0x8000000058b90bfc07a77ad56ed22aaa >> 127;\\n            if (x & 0x10000000000000000000000 > 0) r = r * 0x800000002c5c85fdfc23cdead40da8d6 >> 127;\\n            if (x & 0x8000000000000000000000 > 0) r = r * 0x80000000162e42fefc25eb1571853a66 >> 127;\\n            if (x & 0x4000000000000000000000 > 0) r = r * 0x800000000b17217f7d97f692baacded5 >> 127;\\n            if (x & 0x2000000000000000000000 > 0) r = r * 0x80000000058b90bfbead3b8b5dd254d7 >> 127;\\n            if (x & 0x1000000000000000000000 > 0) r = r * 0x8000000002c5c85fdf4eedd62f084e67 >> 127;\\n            if (x & 0x800000000000000000000 > 0) r = r * 0x800000000162e42fefa58aef378bf586 >> 127;\\n            if (x & 0x400000000000000000000 > 0) r = r * 0x8000000000b17217f7d24a78a3c7ef02 >> 127;\\n            if (x & 0x200000000000000000000 > 0) r = r * 0x800000000058b90bfbe9067c93e474a6 >> 127;\\n            if (x & 0x100000000000000000000 > 0) r = r * 0x80000000002c5c85fdf47b8e5a72599f >> 127;\\n            if (x & 0x80000000000000000000 > 0) r = r * 0x8000000000162e42fefa3bdb315934a2 >> 127;\\n            if (x & 0x40000000000000000000 > 0) r = r * 0x80000000000b17217f7d1d7299b49c46 >> 127;\\n            if (x & 0x20000000000000000000 > 0) r = r * 0x8000000000058b90bfbe8e9a8d1c4ea0 >> 127;\\n            if (x & 0x10000000000000000000 > 0) r = r * 0x800000000002c5c85fdf4745969ea76f >> 127;\\n            if (x & 0x8000000000000000000 > 0) r = r * 0x80000000000162e42fefa3a0df5373bf >> 127;\\n            if (x & 0x4000000000000000000 > 0) r = r * 0x800000000000b17217f7d1cff4aac1e1 >> 127;\\n            if (x & 0x2000000000000000000 > 0) r = r * 0x80000000000058b90bfbe8e7db95a2f1 >> 127;\\n            if (x & 0x1000000000000000000 > 0) r = r * 0x8000000000002c5c85fdf473e61ae1f8 >> 127;\\n            if (x & 0x800000000000000000 > 0) r = r * 0x800000000000162e42fefa39f121751c >> 127;\\n            if (x & 0x400000000000000000 > 0) r = r * 0x8000000000000b17217f7d1cf815bb96 >> 127;\\n            if (x & 0x200000000000000000 > 0) r = r * 0x800000000000058b90bfbe8e7bec1e0d >> 127;\\n            if (x & 0x100000000000000000 > 0) r = r * 0x80000000000002c5c85fdf473dee5f17 >> 127;\\n            if (x & 0x80000000000000000 > 0) r = r * 0x8000000000000162e42fefa39ef5438f >> 127;\\n            if (x & 0x40000000000000000 > 0) r = r * 0x80000000000000b17217f7d1cf7a26c8 >> 127;\\n            if (x & 0x20000000000000000 > 0) r = r * 0x8000000000000058b90bfbe8e7bcf4a4 >> 127;\\n            if (x & 0x10000000000000000 > 0) r = r * 0x800000000000002c5c85fdf473de72a2 >> 127;\\n            /* Precision reduced to 64 bits\\n            if (x & 0x8000000000000000 > 0) r = r * 0x80000000000000162e42fefa39ef3765 >> 127;\\n            if (x & 0x4000000000000000 > 0) r = r * 0x800000000000000b17217f7d1cf79b37 >> 127;\\n            if (x & 0x2000000000000000 > 0) r = r * 0x80000000000000058b90bfbe8e7bcd7d >> 127;\\n            if (x & 0x1000000000000000 > 0) r = r * 0x8000000000000002c5c85fdf473de6b6 >> 127;\\n            if (x & 0x800000000000000 > 0) r = r * 0x800000000000000162e42fefa39ef359 >> 127;\\n            if (x & 0x400000000000000 > 0) r = r * 0x8000000000000000b17217f7d1cf79ac >> 127;\\n            if (x & 0x200000000000000 > 0) r = r * 0x800000000000000058b90bfbe8e7bcd6 >> 127;\\n            if (x & 0x100000000000000 > 0) r = r * 0x80000000000000002c5c85fdf473de6a >> 127;\\n            if (x & 0x80000000000000 > 0) r = r * 0x8000000000000000162e42fefa39ef35 >> 127;\\n            if (x & 0x40000000000000 > 0) r = r * 0x80000000000000000b17217f7d1cf79a >> 127;\\n            if (x & 0x20000000000000 > 0) r = r * 0x8000000000000000058b90bfbe8e7bcd >> 127;\\n            if (x & 0x10000000000000 > 0) r = r * 0x800000000000000002c5c85fdf473de6 >> 127;\\n            if (x & 0x8000000000000 > 0) r = r * 0x80000000000000000162e42fefa39ef3 >> 127;\\n            if (x & 0x4000000000000 > 0) r = r * 0x800000000000000000b17217f7d1cf79 >> 127;\\n            if (x & 0x2000000000000 > 0) r = r * 0x80000000000000000058b90bfbe8e7bc >> 127;\\n            if (x & 0x1000000000000 > 0) r = r * 0x8000000000000000002c5c85fdf473de >> 127;\\n            if (x & 0x800000000000 > 0) r = r * 0x800000000000000000162e42fefa39ef >> 127;\\n            if (x & 0x400000000000 > 0) r = r * 0x8000000000000000000b17217f7d1cf7 >> 127;\\n            if (x & 0x200000000000 > 0) r = r * 0x800000000000000000058b90bfbe8e7b >> 127;\\n            if (x & 0x100000000000 > 0) r = r * 0x80000000000000000002c5c85fdf473d >> 127;\\n            if (x & 0x80000000000 > 0) r = r * 0x8000000000000000000162e42fefa39e >> 127;\\n            if (x & 0x40000000000 > 0) r = r * 0x80000000000000000000b17217f7d1cf >> 127;\\n            if (x & 0x20000000000 > 0) r = r * 0x8000000000000000000058b90bfbe8e7 >> 127;\\n            if (x & 0x10000000000 > 0) r = r * 0x800000000000000000002c5c85fdf473 >> 127;\\n            if (x & 0x8000000000 > 0) r = r * 0x80000000000000000000162e42fefa39 >> 127;\\n            if (x & 0x4000000000 > 0) r = r * 0x800000000000000000000b17217f7d1c >> 127;\\n            if (x & 0x2000000000 > 0) r = r * 0x80000000000000000000058b90bfbe8e >> 127;\\n            if (x & 0x1000000000 > 0) r = r * 0x8000000000000000000002c5c85fdf47 >> 127;\\n            if (x & 0x800000000 > 0) r = r * 0x800000000000000000000162e42fefa3 >> 127;\\n            if (x & 0x400000000 > 0) r = r * 0x8000000000000000000000b17217f7d1 >> 127;\\n            if (x & 0x200000000 > 0) r = r * 0x800000000000000000000058b90bfbe8 >> 127;\\n            if (x & 0x100000000 > 0) r = r * 0x80000000000000000000002c5c85fdf4 >> 127;\\n            if (x & 0x80000000 > 0) r = r * 0x8000000000000000000000162e42fefa >> 127;\\n            if (x & 0x40000000 > 0) r = r * 0x80000000000000000000000b17217f7d >> 127;\\n            if (x & 0x20000000 > 0) r = r * 0x8000000000000000000000058b90bfbe >> 127;\\n            if (x & 0x10000000 > 0) r = r * 0x800000000000000000000002c5c85fdf >> 127;\\n            if (x & 0x8000000 > 0) r = r * 0x80000000000000000000000162e42fef >> 127;\\n            if (x & 0x4000000 > 0) r = r * 0x800000000000000000000000b17217f7 >> 127;\\n            if (x & 0x2000000 > 0) r = r * 0x80000000000000000000000058b90bfb >> 127;\\n            if (x & 0x1000000 > 0) r = r * 0x8000000000000000000000002c5c85fd >> 127;\\n            if (x & 0x800000 > 0) r = r * 0x800000000000000000000000162e42fe >> 127;\\n            if (x & 0x400000 > 0) r = r * 0x8000000000000000000000000b17217f >> 127;\\n            if (x & 0x200000 > 0) r = r * 0x800000000000000000000000058b90bf >> 127;\\n            if (x & 0x100000 > 0) r = r * 0x80000000000000000000000002c5c85f >> 127;\\n            if (x & 0x80000 > 0) r = r * 0x8000000000000000000000000162e42f >> 127;\\n            if (x & 0x40000 > 0) r = r * 0x80000000000000000000000000b17217 >> 127;\\n            if (x & 0x20000 > 0) r = r * 0x8000000000000000000000000058b90b >> 127;\\n            if (x & 0x10000 > 0) r = r * 0x800000000000000000000000002c5c85 >> 127;\\n            if (x & 0x8000 > 0) r = r * 0x80000000000000000000000000162e42 >> 127;\\n            if (x & 0x4000 > 0) r = r * 0x800000000000000000000000000b1721 >> 127;\\n            if (x & 0x2000 > 0) r = r * 0x80000000000000000000000000058b90 >> 127;\\n            if (x & 0x1000 > 0) r = r * 0x8000000000000000000000000002c5c8 >> 127;\\n            if (x & 0x800 > 0) r = r * 0x800000000000000000000000000162e4 >> 127;\\n            if (x & 0x400 > 0) r = r * 0x8000000000000000000000000000b172 >> 127;\\n            if (x & 0x200 > 0) r = r * 0x800000000000000000000000000058b9 >> 127;\\n            if (x & 0x100 > 0) r = r * 0x80000000000000000000000000002c5c >> 127;\\n            if (x & 0x80 > 0) r = r * 0x8000000000000000000000000000162e >> 127;\\n            if (x & 0x40 > 0) r = r * 0x80000000000000000000000000000b17 >> 127;\\n            if (x & 0x20 > 0) r = r * 0x8000000000000000000000000000058b >> 127;\\n            if (x & 0x10 > 0) r = r * 0x800000000000000000000000000002c5 >> 127;\\n            if (x & 0x8 > 0) r = r * 0x80000000000000000000000000000162 >> 127;\\n            if (x & 0x4 > 0) r = r * 0x800000000000000000000000000000b1 >> 127;\\n            if (x & 0x2 > 0) r = r * 0x80000000000000000000000000000058 >> 127;\\n            if (x & 0x1 > 0) r = r * 0x8000000000000000000000000000002c >> 127;\\n            */\\n\\n            r >>= 127 - (x >> 121);\\n\\n            z = uint128(r);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc821bcf1cd823684693234c23da7c1a92fee7dfff9ace84afb86cf377b9aa1b9\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
    "bytecode": "0x60a060405234801561001057600080fd5b5060405161135238038061135283398101604081905261002f91610044565b60601b6001600160601b031916608052610072565b600060208284031215610055578081fd5b81516001600160a01b038116811461006b578182fd5b9392505050565b60805160601c61122161013160003960008181610119015281816101f50152818161028b0152818161032b015281816103690152818161047f0152818161055b01528181610596015281816105bd0152818161065d0152818161069a01528181610738015281816107f90152818161089b0152818161093d015281816109df01528181610afb01528181610b8d01528181610bcd01528181610c6b01528181610d8701528181610e2701528181610e640152610f0201526112216000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063a4800a751161005b578063a4800a75146100d1578063c2eebdcf146100e6578063c560ce9a146100f9578063cea55f571461010c5761007d565b80632db1187f1461008257806349f3bb96146100ab578063a0c8ee96146100be575b600080fd5b610095610090366004611046565b610114565b6040516100a29190611110565b60405180910390f35b6100956100b9366004611012565b610286565b6100956100cc366004611046565b61047a565b6100d9610594565b6040516100a29190611098565b6100956100f4366004611012565b6105b8565b610095610107366004611012565b6107f4565b610095610d82565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b15801561017c57600080fd5b505afa158015610190573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b49190611075565b506040517fb5a45a6500000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b5a45a659061022e90849088908890600401611119565b60206040518083038186803b15801561024657600080fd5b505afa15801561025a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061027e919061102e565b949350505050565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b1580156102ee57600080fd5b505afa158015610302573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103269190611075565b5090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166331e2759984837f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f87623a16040518163ffffffff1660e01b815260040160206040518083038186803b1580156103cd57600080fd5b505afa1580156103e1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610405919061102e565b6040518463ffffffff1660e01b8152600401610423939291906110b9565b60206040518083038186803b15801561043b57600080fd5b505afa15801561044f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610473919061102e565b9392505050565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b1580156104e257600080fd5b505afa1580156104f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051a9190611075565b506040517f58796c2800000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906358796c289061022e90849088908890600401611119565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b15801561062057600080fd5b505afa158015610634573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106589190611075565b5090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663c2aeb6b9827f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f16673a46040518163ffffffff1660e01b815260040160206040518083038186803b1580156106fe57600080fd5b505afa158015610712573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610736919061102e565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b15801561079c57600080fd5b505afa1580156107b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d4919061102e565b876040518563ffffffff1660e01b81526004016104239493929190611154565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b15801561085c57600080fd5b505afa158015610870573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108949190611075565b50905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f16673a46040518163ffffffff1660e01b815260040160206040518083038186803b1580156108ff57600080fd5b505afa158015610913573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610937919061102e565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b1580156109a157600080fd5b505afa1580156109b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109d9919061102e565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663fedf096a6040518163ffffffff1660e01b815260040160206040518083038186803b158015610a4357600080fd5b505afa158015610a57573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7b919061102e565b90506000866001811115610ab8577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b1415610b8b576040517f4ee1b72d00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690634ee1b72d90610b389085908790899087904290600401611181565b604080518083038186803b158015610b4f57600080fd5b505afa158015610b63573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b879190611075565b9250505b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630e3e851e878686867f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16633ea5b3956040518163ffffffff1660e01b815260040160206040518083038186803b158015610c3157600080fd5b505afa158015610c45573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c69919061102e565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f87623a16040518163ffffffff1660e01b815260040160206040518083038186803b158015610ccf57600080fd5b505afa158015610ce3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d07919061102e565b6040518763ffffffff1660e01b8152600401610d28969594939291906110da565b60206040518083038186803b158015610d4057600080fd5b505afa158015610d54573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d78919061102e565b9695505050505050565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b158015610dea57600080fd5b505afa158015610dfe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e229190611075565b5090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16639e5111f0827f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f16673a46040518163ffffffff1660e01b815260040160206040518083038186803b158015610ec857600080fd5b505afa158015610edc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f00919061102e565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b158015610f6657600080fd5b505afa158015610f7a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f9e919061102e565b6040518463ffffffff1660e01b8152600401610fbc9392919061113e565b60206040518083038186803b158015610fd457600080fd5b505afa158015610fe8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061100c919061102e565b91505090565b600060208284031215611023578081fd5b8135610473816111de565b60006020828403121561103f578081fd5b5051919050565b60008060408385031215611058578081fd5b82359150602083013561106a816111de565b809150509250929050565b60008060408385031215611087578182fd5b505080516020909101519092909150565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b606081016110c6856111a4565b938152602081019290925260409091015290565b60c081016110e7886111a4565b968152602081019590955260408501939093526060840191909152608083015260a09091015290565b90815260200190565b8381526020810183905260608101611130836111a4565b826040830152949350505050565b9283526020830191909152604082015260600190565b848152602081018490526040810183905260808101611172836111a4565b82606083015295945050505050565b948552602085019390935260408401919091526060830152608082015260a00190565b600281106111db577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b50565b600281106111db57600080fdfea2646970667358221220cef3a76f153a12cc054174d4bde3a4c4b75986610e79a3063479e2451b6fadf364736f6c63430008000033",
    "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063a4800a751161005b578063a4800a75146100d1578063c2eebdcf146100e6578063c560ce9a146100f9578063cea55f571461010c5761007d565b80632db1187f1461008257806349f3bb96146100ab578063a0c8ee96146100be575b600080fd5b610095610090366004611046565b610114565b6040516100a29190611110565b60405180910390f35b6100956100b9366004611012565b610286565b6100956100cc366004611046565b61047a565b6100d9610594565b6040516100a29190611098565b6100956100f4366004611012565b6105b8565b610095610107366004611012565b6107f4565b610095610d82565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b15801561017c57600080fd5b505afa158015610190573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b49190611075565b506040517fb5a45a6500000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b5a45a659061022e90849088908890600401611119565b60206040518083038186803b15801561024657600080fd5b505afa15801561025a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061027e919061102e565b949350505050565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b1580156102ee57600080fd5b505afa158015610302573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103269190611075565b5090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166331e2759984837f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f87623a16040518163ffffffff1660e01b815260040160206040518083038186803b1580156103cd57600080fd5b505afa1580156103e1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610405919061102e565b6040518463ffffffff1660e01b8152600401610423939291906110b9565b60206040518083038186803b15801561043b57600080fd5b505afa15801561044f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610473919061102e565b9392505050565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b1580156104e257600080fd5b505afa1580156104f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051a9190611075565b506040517f58796c2800000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906358796c289061022e90849088908890600401611119565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b15801561062057600080fd5b505afa158015610634573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106589190611075565b5090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663c2aeb6b9827f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f16673a46040518163ffffffff1660e01b815260040160206040518083038186803b1580156106fe57600080fd5b505afa158015610712573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610736919061102e565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b15801561079c57600080fd5b505afa1580156107b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d4919061102e565b876040518563ffffffff1660e01b81526004016104239493929190611154565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b15801561085c57600080fd5b505afa158015610870573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108949190611075565b50905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f16673a46040518163ffffffff1660e01b815260040160206040518083038186803b1580156108ff57600080fd5b505afa158015610913573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610937919061102e565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b1580156109a157600080fd5b505afa1580156109b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109d9919061102e565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663fedf096a6040518163ffffffff1660e01b815260040160206040518083038186803b158015610a4357600080fd5b505afa158015610a57573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7b919061102e565b90506000866001811115610ab8577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b1415610b8b576040517f4ee1b72d00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690634ee1b72d90610b389085908790899087904290600401611181565b604080518083038186803b158015610b4f57600080fd5b505afa158015610b63573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b879190611075565b9250505b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630e3e851e878686867f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16633ea5b3956040518163ffffffff1660e01b815260040160206040518083038186803b158015610c3157600080fd5b505afa158015610c45573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c69919061102e565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f87623a16040518163ffffffff1660e01b815260040160206040518083038186803b158015610ccf57600080fd5b505afa158015610ce3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d07919061102e565b6040518763ffffffff1660e01b8152600401610d28969594939291906110da565b60206040518083038186803b158015610d4057600080fd5b505afa158015610d54573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d78919061102e565b9695505050505050565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a3e6ba946040518163ffffffff1660e01b8152600401604080518083038186803b158015610dea57600080fd5b505afa158015610dfe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e229190611075565b5090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16639e5111f0827f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f16673a46040518163ffffffff1660e01b815260040160206040518083038186803b158015610ec857600080fd5b505afa158015610edc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f00919061102e565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b158015610f6657600080fd5b505afa158015610f7a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f9e919061102e565b6040518463ffffffff1660e01b8152600401610fbc9392919061113e565b60206040518083038186803b158015610fd457600080fd5b505afa158015610fe8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061100c919061102e565b91505090565b600060208284031215611023578081fd5b8135610473816111de565b60006020828403121561103f578081fd5b5051919050565b60008060408385031215611058578081fd5b82359150602083013561106a816111de565b809150509250929050565b60008060408385031215611087578182fd5b505080516020909101519092909150565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b606081016110c6856111a4565b938152602081019290925260409091015290565b60c081016110e7886111a4565b968152602081019590955260408501939093526060840191909152608083015260a09091015290565b90815260200190565b8381526020810183905260608101611130836111a4565b826040830152949350505050565b9283526020830191909152604082015260600190565b848152602081018490526040810183905260808101611172836111a4565b82606083015295945050505050565b948552602085019390935260408401919091526060830152608082015260a00190565b600281106111db577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b50565b600281106111db57600080fdfea2646970667358221220cef3a76f153a12cc054174d4bde3a4c4b75986610e79a3063479e2451b6fadf364736f6c63430008000033",
    "devdoc": {
      "author": "Alberto Cuesta Caada, Jacob Eliosoff, Alex Roan",
      "kind": "dev",
      "methods": {
        "debtRatio()": {
          "returns": {
            "ratio": "Debt ratio"
          }
        },
        "ethBuffer(uint8)": {
          "returns": {
            "buffer": "ETH buffer"
          }
        },
        "ethToUsm(uint256,uint8)": {
          "params": {
            "ethAmount": "The amount of ETH to convert"
          },
          "returns": {
            "usmOut": "The amount of USM"
          }
        },
        "fumPrice(uint8)": {
          "returns": {
            "price": "FUM price in ETH terms"
          }
        },
        "usmPrice(uint8)": {
          "returns": {
            "price": "USM price in ETH terms"
          }
        },
        "usmToEth(uint256,uint8)": {
          "params": {
            "usmAmount": "The amount of USM to convert"
          },
          "returns": {
            "ethOut": "The amount of ETH"
          }
        }
      },
      "title": "USM view-only proxy",
      "version": 1
    },
    "userdoc": {
      "kind": "user",
      "methods": {
        "debtRatio()": {
          "notice": "Calculate debt ratio."
        },
        "ethBuffer(uint8)": {
          "notice": "Calculate the amount of ETH in the buffer."
        },
        "ethToUsm(uint256,uint8)": {
          "notice": "Convert ETH amount to USM using the latest oracle ETH/USD price."
        },
        "fumPrice(uint8)": {
          "notice": "Calculate the *marginal* price of FUM (in ETH terms) - that is, of the next unit, before price start sliding."
        },
        "usmPrice(uint8)": {
          "notice": "Calculate the *marginal* price of USM (in ETH terms) - that is, of the next unit, before price start sliding."
        },
        "usmToEth(uint256,uint8)": {
          "notice": "Convert USM amount to ETH using the latest oracle ETH/USD price."
        }
      },
      "version": 1
    },
    "storageLayout": {
      "storage": [],
      "types": null
    }
  }